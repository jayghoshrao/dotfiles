#!/bin/python

"""
MIRROR/MIR (rewritten)
- rsync wrapper to sync files within a given directory to/from servers
- requires a .mirrors file in the root directory of sync
    - line format: <name> <path/to/server/root>
    - example: jureca jureca12:/p/project/cjibg12/scratch

USAGE: 
    `mir push TARGETS...-d`
    `mir pull SOURCE`

WARNINGS:
    - rsync can be dangerous if not used properly
    - .git folder is currently ignored by default
"""

# TODO: Find all .mirror files in all parents and mash them together. Closest file should override farthest file.
# TODO: Set autocompletable choices for sources and targets from remotes.keys()
# TODO: Allow diffing with remotes
# TODO: Allow setting root folder via args

import os
import sys
import time
import argparse
import subprocess
from rich import print
from rich.pretty import pprint
from ruamel.yaml import YAML
from pathlib import Path
# from addict import Dict
from dataclasses import dataclass, field

yaml = YAML(typ='safe')

PRECMD="rsync -avzhP"
PRECMDLIST = PRECMD.split()

@dataclass
class Config:
    remotes: dict[str,str] = field(default_factory=dict)
    files: list[str] = field(default_factory=list)
    excludes: list[str] = field(default_factory=list) 
    mode: str = field(default_factory=str)
    dry_run: bool = False
    mkdir: bool = False
    delete: bool = False
    delete_excluded: bool = False

    def update(self, in_dict):
        for key in self.__dataclass_fields__: 
            if not in_dict.get(key):
                continue
            elif isinstance(self.__dict__[key], list):
                self.__dict__[key]= list(set(self.__dict__[key] + in_dict.get(key)))
            elif isinstance(self.__dict__[key], dict):
                self.__dict__[key].update(in_dict.get('remotes', {}))
            else:
                self.__dict__[key] = in_dict.get(key)

def findup(name, path:Path):
    while str(path) != '/':
        files = [ p.name for p in path.glob('*') if p.is_file() ]
        if name in files:
            return path 
        path = path.parent

## NOTE: Unsure if it's necessary to have a cumulatively patched ini file. 
## Why would we need this functionality if we could just create one at the root and use that?
## Do we just use the first encountered .mirrors file as root? 
## we would need cumulative patching if we have more than just remotes in the config files, such as excludes etc. We then only specify the excludes in the current folder? Per subfolder excludes
# def parse_ini_cumulatively(name, path:Path):
#     remotes = {}
#     paths = []
#     while str(path) != '/':
#         files = [ p.name for p in path.glob('*') if p.is_file() ]
#         if name in files:
#             remotes.update(readINI(path / name))
#             paths.append(path)
#         path = path.parent
#     return path[0]

def find_and_parse(filename=".mirrors.yaml", parser=yaml.load):
    cwd = Path().resolve()
    root = findup(filename, cwd)
    if root is not None:
        print("found root: ", root)
        return root, parser(root / filename)
    return None, {}

def find_files(ignore_files=[], ignore_dirs=['.git']):
    # return [ p for p in Path('.').rglob('*') if p.is_file() and STATEDIR not in p.parents]
    ignore_dirs = [Path(dir) for dir in ignore_dirs]
    ignore_files = [Path(f) for f in ignore_files]

    files = [ p for p in Path('.').rglob('*') if p.is_file() ]

    for dir in ignore_dirs:
        files = list(filter(lambda f: dir not in f.parents, files))
    for ignore_file in ignore_files:
        files = list(filter(lambda f: ignore_file != str(f), files))

    return files

def readINI(filestring):
    dictionary = {}
    arr = []
    try:
        with open(filestring, "r") as fp:
            for line in fp:
                arr = line.strip().split(' ')
                dictionary[arr[0]] = ' '.join(arr[1:])
    except:
        raise RuntimeError("Error: .mirrors file not found!")

    return dictionary

def push(files, targets, remotes, root, mkdir=False):
    PRECMDLIST.append('--relative')
    if targets == ['all']:
        targets = [ x for x in remotes ]
    for target in targets:
        if target in remotes:
            cmdlist = PRECMDLIST[:]
            if files:
                for file in files:
                    cmdlist.append(file)
            else:
                cmdlist.append('.')
            cmdlist.append(str(Path(remotes[target]) / Path('.').resolve().relative_to(str(root)) ) + os.sep)

            if mkdir: 
                mkdir_cmd = f'mkdir -p { str(Path(remotes[target])).split(":")[-1] / Path(".").resolve().relative_to(str(root))}{os.sep}'
                if ':' in remotes[target]:
                    mkdir_cmd = f'ssh {target} {mkdir_cmd}' 
                print(mkdir_cmd)
                subprocess.run(mkdir_cmd.split())

            print(cmdlist)
            subprocess.run(cmdlist)
        else:
            raise RuntimeError(f"Remote {target} not found. Please check {root}/.mirrors.")

def pull(files, source, remotes, root):
    if source in remotes:
        cmdlist = PRECMDLIST[:]
        if files != [] and files is not None:
            for file in files:
                cmdlist.append(str(Path(remotes[source]) / Path('.').resolve().relative_to(str(root)) / file ))
        else: 
            cmdlist.append(str(Path(remotes[source]) / Path('.').resolve().relative_to(str(root))) + os.sep)
        cmdlist.append('.')
        print(cmdlist)
        subprocess.run(cmdlist)

def main():
    ap = argparse.ArgumentParser()

    # meg = ap.add_mutually_exclusive_group()
    # meg.add_argument("-t", "--target", nargs='*', help="target servers")
    # meg.add_argument("-s", "--source", help="source server")

    subparsers = ap.add_subparsers(dest='mode')

    sub_push = subparsers.add_parser('push', help='PUSH to multiple sources')
    sub_push.add_argument('target', nargs='*', help="target servers")
    sub_push.add_argument('-f', '--files', nargs='*', help='files or directories to sync')
    sub_push.add_argument('-e', '--excludes', nargs='*', action='extend', default = ['.git', '.state' ], help='exclude PATTERN')

    sub_pull = subparsers.add_parser('pull', help='pull from ONE source')
    sub_pull.add_argument('source', nargs='?', help="target servers")
    sub_pull.add_argument('-f', '--files', nargs='*', help='files or directories to sync')
    sub_pull.add_argument('-e', '--excludes', nargs='*', action='extend', default = ['.git', '.state' ], help='exclude PATTERN')

    sub_diff= subparsers.add_parser('diff', help='list remotes found in .mirrors file')
    sub_diff.add_argument('diff', help="target servers")

    sub_edit= subparsers.add_parser('edit', help='list remotes found in .mirrors file')

    # TODO: This might get in the way of how relative paths are handled. Needs CAREFUL testing
    # TODO: implement -r without key, just value of remote, always use a dummy key 
    ap.add_argument("-r", "--remote", help="Don't use .mirrors file, use this specified remote location")

    ap.add_argument("-d", "--dry-run", action='store_true', help="Only show which commands will run")
    ap.add_argument("-m", "--mkdir", action='store_true', help="Run `mkdir -p` to enforce folder creation before sync")
    ap.add_argument("--delete", action='store_true', help="delete")
    ap.add_argument("--delete-excluded", action='store_true', help="delete excluded files as well")

    args = vars(ap.parse_args())

    config = Config()
    config.update(args)

    root = None
    cwd = Path().resolve()
    if args['remote']: 
        config.remotes = {'args_remote': args['remote']}
        if config.mode == 'push':
            args['target'] = [ 'args_remote' ]
        elif config.mode == 'pull':
            args['source'] = 'args_remote'
        root = cwd
    else:
        root_yaml, config_yaml = find_and_parse('.mirrors.yaml', yaml.load)
        if config_yaml:
            config.update(config_yaml)
            root = root_yaml

    if root:
        pprint(config, expand_all=True)
    else:
        return

    if not config.mode:
        return

    # if not args['files']:
    #     args['files'] = ['.']

    if config.delete:
        PRECMDLIST.append('--delete')

    if config.delete_excluded:
        PRECMDLIST.append(f"--delete-excluded")

    if config.dry_run:
        PRECMDLIST.append(f"--dry-run")

    if args.get('source') or args.get('target'): 
        for item in config.excludes: 
            PRECMDLIST.append(f"--exclude={item}")

    if config.mode == 'push' and args.get('target'): 
        assert all(t in config.remotes.keys() for t in args['target'])
        warn = input(f"PUSH to {args['target']}? (y/Y/ENTER to continue)")
        if warn.lower() == 'y' or warn == '': 
            push(config.files, args['target'], config.remotes, root, mkdir=config.mkdir)
    elif config.mode == 'pull' and args.get('source'):
        assert args['source'] in config.remotes.keys()
        warn = input(f"PULL from {args['source']}? (y/Y/ENTER to continue)")
        if warn.lower() == 'y' or warn == '': 
            pull(config.files, args['source'], config.remotes, root)
    elif config.mode == 'diff':
        pass
        # Get full paths of dirs
        # Find a difflib
    elif config.mode == 'edit':
        editor = os.environ.get('EDITOR', 'vi')
        print(f"Opening config file: {root / '.mirrors.yaml'}")
        time.sleep(1)
        subprocess.run([editor, root / '.mirrors.yaml'])

if __name__ == "__main__":
    main()
