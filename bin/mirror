#!/bin/python

"""
MIRROR/MIR (rewritten)
- rsync wrapper to sync files within a given directory to/from servers
- requires a .mirrors file in the root directory of sync
    - line format: <name> <path/to/server/root>
    - example: jureca jureca12:/p/project/cjibg12/scratch

USAGE: 
    `mir push TARGETS...-d`
    `mir push TARGETS...`
    `mir pull SOURCE`
    `mir FILES... -t TARGETS...`

WARNINGS:
    - rsync can be dangerous if not used properly
    - .git folder is currently ignored by default
"""

# TODO: Find all .mirror files in all parents and mash them together. Closest file should override farthest file.
# TODO: Set autocompletable choices for sources and targets from remotes.keys()
# TODO: Allow diffing with remotes
# TODO: Allow specifying excludes in .mirrors
# TODO: YAML .mirrors

import os
import sys
import argparse
import subprocess
from rich import print
from rich.pretty import pprint

from pathlib import Path

PRECMD="rsync -avzhP"
PRECMDLIST = PRECMD.split()

def findup(name, path:Path):
    while str(path) != '/':
        files = [ p.name for p in path.glob('*') if p.is_file() ]
        if name in files:
            return path 
        path = path.parent

def find_files(ignore_files=[], ignore_dirs=['.git']):
    # return [ p for p in Path('.').rglob('*') if p.is_file() and STATEDIR not in p.parents]
    ignore_dirs = [Path(dir) for dir in ignore_dirs]
    ignore_files = [Path(f) for f in ignore_files]

    files = [ p for p in Path('.').rglob('*') if p.is_file() ]

    for dir in ignore_dirs:
        files = list(filter(lambda f: dir not in f.parents, files))
    for ignore_file in ignore_files:
        files = list(filter(lambda f: ignore_file != str(f), files))

    return files

def readINI(filestring):
    dictionary = {}
    arr = []
    try:
        with open(filestring, "r") as fp:
            for line in fp:
                arr = line.strip().split(' ')
                dictionary[arr[0]] = ' '.join(arr[1:])
    except:
        raise RuntimeError("Error: .mirrors file not found!")

    return dictionary

def push(files, targets, remotes, root, mkdir=False):
    PRECMDLIST.append('--relative')
    if targets == ['all']:
        targets = [ x for x in remotes ]
    for target in targets:
        if target in remotes:
            cmdlist = PRECMDLIST[:]
            if files:
                for file in files:
                    cmdlist.append(file)
            else:
                cmdlist.append('.')
            cmdlist.append(str(Path(remotes[target]) / Path('.').resolve().relative_to(str(root)) ) + os.sep)

            if mkdir: 
                mkdir_cmd = f'mkdir -p { str(Path(remotes[target])).split(":")[-1] / Path(".").resolve().relative_to(str(root))}{os.sep}'
                if ':' in remotes[target]:
                    mkdir_cmd = f'ssh {target} {mkdir_cmd}' 
                print(mkdir_cmd)
                subprocess.run(mkdir_cmd.split())

            print(cmdlist)
            subprocess.run(cmdlist)
        else:
            raise RuntimeError(f"Remote {target} not found. Please check {root}/.mirrors.")

def pull(files, source, remotes, root):
    if source in remotes:
        cmdlist = PRECMDLIST[:]
        if files != [] and files is not None:
            for file in files:
                cmdlist.append(str(Path(remotes[source]) / Path('.').resolve().relative_to(str(root)) / file ))
        else: 
            cmdlist.append(str(Path(remotes[source]) / Path('.').resolve().relative_to(str(root))) + os.sep)
        cmdlist.append('.')
        print(cmdlist)
        subprocess.run(cmdlist)

def main():
    ap = argparse.ArgumentParser()

    # meg = ap.add_mutually_exclusive_group()
    # meg.add_argument("-t", "--target", nargs='*', help="target servers")
    # meg.add_argument("-s", "--source", help="source server")

    subparsers = ap.add_subparsers()

    sub_push = subparsers.add_parser('push', help='PUSH to multiple sources')
    sub_push.add_argument('target', nargs='*', help="target servers")
    sub_push.add_argument('-f', '--files', nargs='*', help='files or directories to sync')
    sub_push.add_argument('-e', '--exclude', nargs='*', action='extend', default = ['.git', '.state' ], help='exclude PATTERN')

    sub_pull = subparsers.add_parser('pull', help='pull from ONE source')
    sub_pull.add_argument('source', help="target servers")
    sub_pull.add_argument('-f', '--files', nargs='*', help='files or directories to sync')
    sub_pull.add_argument('-e', '--exclude', nargs='*', action='extend', default = ['.git', '.state' ], help='exclude PATTERN')

    sub_list = subparsers.add_parser('list', help='list remotes found in .mirrors file')
    sub_list.add_argument('list', action='store_true', default=False)

    # TODO: This might get in the way of how relative paths are handled. Needs CAREFUL testing
    ap.add_argument("-r", "--remote", nargs=2, action='append', help="Don't use .mirrors file, use this specified remote")
    ap.add_argument("-d", "--dry-run", action='store_true', help="Only show which commands will run")
    ap.add_argument("-m", "--mkdir", action='store_true', help="Run `mkdir -p` to enforce folder creation before sync")
    ap.add_argument("--delete", action='store_true', help="delete")
    ap.add_argument("--delete-excluded", action='store_true', help="delete excluded files as well")

    args = vars(ap.parse_args())
    pprint(args, expand_all=True)

    cwd = Path().resolve()
    if args['remote']: 
        remote = {k:v for k,v in args['remote']}
        root = cwd
    else: 
        root = findup(".mirrors", cwd)
        if root is None:
            print("No .mirrors found in current or parent directories.")
            sys.exit()
        print("found root: ", root)
        inifile = root / ".mirrors"
        remote = readINI(inifile)

    # if not args['files']:
    #     args['files'] = ['.']

    if args.get('list'):
        pprint(remote, expand_all=True)

    if args['delete']:
        PRECMDLIST.append('--delete')

    if args['delete_excluded']:
        PRECMDLIST.append(f"--delete-excluded")

    if args['dry_run']:
        PRECMDLIST.append(f"--dry-run")

    if args.get('source') or args.get('target'): 
        for item in args['exclude']: 
            print(f"NOTE: excluding {item}")
            PRECMDLIST.append(f"--exclude={item}")

    if args.get('target'): 
        warn = input(f"PUSH to {args['target']}? (y/Y/ENTER to continue)")
        if warn.lower() == 'y' or warn == '': 
            push(args['files'], args['target'], remote, root, mkdir=args['mkdir'])
    elif args.get('source'):
        warn = input(f"PULL from {args['source']}? (y/Y/ENTER to continue)")
        if warn.lower() == 'y' or warn == '': 
            pull(args['files'], args['source'], remote, root)

if __name__ == "__main__":
    main()
