#!/bin/python3

# depends on the mplstyle files from https://github.com/garrettj403/SciencePlots
# USAGE: ./plot <file> <file> -o plot.pdf 

# TODO: speed up for large files: file-read can be done via np.memmap for binary

""" Name TBD: plotipy, plotti, plote, ploot, plawt, plaut, pluto

Takes in CSV files with X-Y info (or just Y info) and plots it.

- Files: with/without header, separator character
- Axes: axis label, limits, log-scale
- Plot types: Line, Scatter, Violin, Histogram, horizontal and vertical lines
- Configurable: Labels, linewidth, linestyles, markers, legend, fill
- Transformations: xscale, yscale, normalization, smoothen
"""

import matplotlib as mpl
import matplotlib.pyplot as plt
from cycler import cycler
# import csv
from itertools import cycle, islice
import sys
import argparse
from subprocess import run
from pathlib import Path
import numpy as np

from matplotlib import ticker

from scipy.interpolate import make_interp_spline, BSpline

# SMOOTH: https://stackoverflow.com/questions/5283649/plot-smooth-line-with-pyplot
# COLORS: https://coolors.co/0c5da5-ffcf70-e08300-bc4b51-ac8cba-474747-225851

# COLORS = ['#0C5DA5', '#00B945', '#FF9500', '#FF2C00', '#845B97', '#474747', '#9e9e9e']
# COLORS = ["#0c5da5","#ffcf70","#e08300","#bc4b51","#ac8cba","#474747","#225851"]
# COLORS = plt.cm.viridis(np.linspace(0, 1,7))


qualitative_colormaps = ['Pastel1', 'Pastel2', 'Paired', 'Accent', 'Dark2', 'Set1', 'Set2', 'Set3', 'tab10', 'tab20', 'tab20b', 'tab20c']

def cmap_colors_to_hex(cmap_colors): 
    # USAGE: cmap_colors_to_hex(plt.cm.tab10.colors)
    return list(map(lambda x: mpl.colors.rgb2hex(x), cmap_colors))

def readCSV(data_path):
    time= []
    conc= []
    with open(data_path, newline='') as csvfile:
        # data = list(csv.reader(csvfile))
        for line in csvfile:
            data_line = line.strip().split(',')
            data_line = list(filter(None, data_line))
            if (data_line != []):
                time.append(float(data_line[0]))
                conc.append(float(data_line[1]))
    return time, conc

## MOve to h5plot
def readCadet(infile, unit, solution='outlet'):
    from cadet import Cadet
    from addict import Dict
    cadetpath = "/home/jayghoshter/local/bin/cadet-cli"
    Cadet.cadet_path = cadetpath
    sim = Cadet()
    sim.filename = infile
    sim.load()
    x = sim.root.output.solution.solution_times
    y = sim.root.output.solution['unit_' + "%03d" % unit]['solution_' + solution]
    return x, y

# def normalize(data):
#     return [ x/data[-1] for x in data ]

def normalize(data, refValue=None):
    """ Normalize array to either max value or given refValue
    """
    if refValue == 'self':
        print("No reference value for normalization provided: Using max point of curve.")
        refValue = max(data)
    return [ x/float(refValue) for x in data ]

def readArray(data_path):
    """ Read single column plain text data files 
    """
    values =[]
    with open(data_path, newline='') as csvfile:
        for line in csvfile:
            values.append(float(line.strip()))
    return values

def readfile(data_path, columns, header=False, xticksColumn=0):
    """ Read x-y CSV-style files
    """
    if ':' in data_path:
        run(['scp', '-rC', data_path, '/tmp/plotting.csv'])
        data_path = '/tmp/plotting.csv'

    x = []
    y = []
    xticks = []
    # columns = [0, 1]
    delimiter = ' '
    with open(data_path, newline='') as csvfile:
        if ',' in csvfile.readline():
            delimiter = ','
    with open(data_path, newline='') as infile:
        # data = list(csv.reader(infile))
        if header:
            print(infile.readline())
        for line in infile:
            data_line = line.strip().split(delimiter)
            data_line = list(filter(None, data_line))
            if (data_line != []):
                if len(data_line) == 1:
                    y.append(float(data_line[0]))
                else:
                    x.append(float(data_line[columns[0]]))
                    y.append(float(data_line[columns[1]]))
                # if columns[0] != -1:
                #     x.append(float(data_line[columns[0]]))
                # y.append(float(data_line[columns[1]]))
                if xticksColumn is not None: 
                    xticks.append(float(data_line[xticksColumn]))

    return x, y, xticks

def scale_axis(vec:list, scale_factor_or_file):
    """ Scale either the x or y axis of a given plot line
    """
    if Path(scale_factor_or_file).expanduser().exists():
        scale_factors = readArray(scale_factor_or_file)
        vec = [ v*s for v,s in zip(vec, scale_factors)]
    else: 
        scale_factor = float(scale_factor_or_file)
        vec = [ v * scale_factor for v in vec ]
    return vec

def setup_main_axis(ax, args):
    """ Main axis and plot setup
    """

    ax.set(title=args['title'])
    ax.set(xlabel=args['xlabel'])
    ax.set(ylabel=args['ylabel'])

    if args['xlog']:
        ax.set(xscale="log")
    if args['ylog']:
        ax.set(yscale="log")

    ax.set_aspect(args['aspect'])
    ax.autoscale(tight=True)

    if args['xlims']:
        ax.set_xlim(args['xlims'])
    if args['ylims']:
        ax.set_ylim(args['ylims'])

    if args['scitick']: 
        ax.ticklabel_format(style='sci', axis='both', scilimits=(0,0))


def setup_twin_axis(ax, args):
    """ Twin axis (parallel y axis) setup
    """
    ax.set(ylabel=args['y2label'])

    if args['y2log']:
        ax.set(yscale="log")

    ax.set_aspect(args['aspect'])
    ax.autoscale(tight=True)

    if args['y2lims']:
        ax.set_ylim(args['y2lims'])

    if args['scitick2']: 
        ax.ticklabel_format(style='sci', axis='both', scilimits=(0,0))

def plot_things(files, ax, args):
    """ High level plotter 
    Reads files, transforms, plots
    """
    xs = []
    ys = []
    lines = []
    for filename,label,linestyle,marker,mfc,linewidth,zorder in zip(files, 
                                                                args['labels'], 
                                                                args['linestyles'], 
                                                                args['markers'], 
                                                                args['marker_face_colors'],
                                                                args['linewidths'], 
                                                                args['zorder']
                                                                ):
        if args['cadet']:
            x, y = readCadet(filename, int(args['cadet'][0]), args['cadet'][1])
            # print(x,y)
        else:
            x, y, xticks = readfile(filename, args['columns'], args['header'], xticksColumn=args['xticks_column'])

        if args['normalize']:
            y = normalize(y, args['normalize'])
        if args['normalize_x']:
            x = normalize(x, args['normalize_x'])

        ## TODO: Allow this to be specified per plot line
        if args['xscale']:
            if x == []:
                x = [1] * len(y)
            x = scale_axis(x, args['xscale'])
        if args['yscale']:
            y = scale_axis(y, args['yscale'])

        if args['smoothen']: 
            xnew = np.linspace(min(x), max(x), args['smoothen']) 
            spl = make_interp_spline(x, y, k=3)  # type: BSpline
            ynew = spl(xnew)
            x = xnew
            y = ynew

        xs.append(x)
        ys.append(y)

        if len(x) > 0: 
            if args['scatter']:
                line = ax.scatter(x, y, label=label.replace('_', '-'), marker=marker)
                lines.append(line)
            else:
                line = ax.plot(x, y, label=label.replace('_', '-'), marker=marker, markerfacecolor=mfc, linestyle=linestyle, linewidth=linewidth, zorder=zorder)
                lines.extend(line)
        else:
            if args['histogram']:
                line = ax.hist(y, bins=args['histogram'])
            elif args['violin']:
                # pass
                line = None
            else:
                line = ax.plot(y, label=label.replace('_', '-'), marker=marker, linestyle=linestyle, linewidth=linewidth)
                lines.extend(line)
        if isinstance(args['fill'], float):
            ax.fill_between(x, y, args['fill'], interpolate=True, hatch=args['hatch'], alpha=args['fill_alpha'])
            plt.rcParams['hatch.linewidth'] = args['hatch_linewidth']



    if args['violin']: 
        ax.violinplot(ys)
        positions = np.arange(len(args['labels'])) + 1
        plt.xticks(positions, args['labels'])
        # positions = np.arange(len(args['labels'])) + 1
        # labels = args['labels']
        # ax.xaxis.set_major_locator(ticker.FixedLocator(positions))
        # ax.xaxis.set_major_formatter(ticker.FixedFormatter(labels))

    return lines


ap = argparse.ArgumentParser()
ap.add_argument("files", nargs='*', help="files to plot")

ap.add_argument("-t", "--title", help="title")
ap.add_argument("-x", "--xlabel", help="xlabel")
ap.add_argument("-y", "--ylabel", help="ylabel")
ap.add_argument("-a", "--aspect", default='auto', help="Set the aspect ratio for the plot")
ap.add_argument("-fs", "--fig-size", nargs=2, default=[4.0, 3.0], type=float, help="Set the figure size for the plot")
ap.add_argument("-xl", "--xlims",nargs=2, type=float, help="x axis limits")
ap.add_argument("-yl", "--ylims",nargs=2, type=float, help="y axis limits")

ap.add_argument("-xtx", "--xticks", nargs='*', type=float, help="x axis tick positions")
ap.add_argument("-xtl", "--xtick-labels", nargs='*', help="x axis tick labels")

ap.add_argument("--xticks-column", type=int, help="Column from input files to count as xticks labels")
ap.add_argument("--scitick", choices=['x', 'y', 'both'], help="Apply scientific tick label formatting")
ap.add_argument("--scitick2", choices=['x', 'y', 'both'], help="Apply scientific tick label formatting to axis 2")

ap.add_argument("-ls", "--linestyles", nargs='*', help="linestyles = solid dashed ...")
ap.add_argument("-lw", "--linewidths", nargs='*', help="linewidth = 0.1 2 ...")
ap.add_argument("-l", "--labels", nargs='*', help="legend labels")
ap.add_argument("-z", "--zorder", nargs='*', type=int, help="zorder for each plot")
ap.add_argument("-m", "--markers", nargs='*', help="markers = s, o, ...")
ap.add_argument("-mfc", "--marker-face-colors", nargs='*', help="marker face colors")
ap.add_argument("-mec", "--marker-edge-colors", nargs='*', help="marker edge colors")

ap.add_argument("-hg", "--histogram", type=int, help="histogram")
ap.add_argument("-s", "--separator", default=',', help="separator character")

ap.add_argument("-f", "--fill", type=float, help="fill area between provided curve and horizontal baseline at given y value.")
ap.add_argument("--fill-color", help="fill area color")
ap.add_argument("--fill-alpha", default=0.2, type=float, help="Alpha for filled area")
ap.add_argument("--hatch", default='xxx', help="hatch style for filled areas")
ap.add_argument("--hatch-linewidth", type=float, default=0.5, help="hatch linewidth for filled areas")

ap.add_argument("--color-cycle-length", type=int, help="Number of colors to cycle through for each line")
ap.add_argument("-cmap", "--colormap", choices = qualitative_colormaps, default='tab10', help="Matplotlib colormap to use")

ap.add_argument("--header", action='store_true', help="CSV file contains header labels")

ap.add_argument("-nl", "--no-legend", action='store_true', help="don't show legend")
ap.add_argument("--legend", nargs=3, default=['upper center', '0.5', '-0.2'], type=str, help="Legend settings: --legend <location> <bbox_to_anchor>")
ap.add_argument("--legend-frameon", action='store_true', help="Draw frame around legend")
ap.add_argument("--legend-size", default='medium', help="Legend font size:int or {'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'}")
ap.add_argument("--legend-ncol", default=1, type=int, help="Number of columns in legend")

ap.add_argument("--smoothen", nargs='?', type=int, const=250, help="Cubic spline interpolation through provided data")

ap.add_argument("-n", "--normalize", nargs='?', const='self', help="normalize y data to given value or 'self'")
ap.add_argument("-nx", "--normalize-x", nargs='?', const='self', help="normalize y data to given value or 'self'")
ap.add_argument("-xs", "--xscale", help="Scale the x axis for all plots by a numerical value or text file with every value")
ap.add_argument("-ys", "--yscale", help="Scale the y axis for all plots by a numerical value or text file with every value")


ap.add_argument("-hl", "--hlines", nargs='*', type=float, help="Add horizontal lines at these y values")
ap.add_argument("-vl", "--vlines", nargs='*', type=float, help="Add vertical lines at these x values")

ap.add_argument("--xlog", action='store_true', help="X axis in log scale")
ap.add_argument("--ylog", action='store_true', help="Y axis in log scale")

ap.add_argument("--scatter", action='store_true', help="Show a scatter plot")
ap.add_argument("--violin", action='store_true', help="Show a violin plot")

ap.add_argument("-o", "--output", help="output file")
ap.add_argument("-w", "--write", nargs='*', help="Write the CSV file (after applying rescaling if any)")
ap.add_argument("--split", action='store_true', help="Split the data into x and y.")

ap.add_argument("--cadet", nargs=2, help="Read h5 files. --cadet <unit_num> <solution_path>")

ap.add_argument("--style", nargs='*', default=['science'], help="Change the plotting style with SciencePlots")

ap.add_argument("--twinx", nargs='*', default = [], help="Files to plot on an alternate y axis")
ap.add_argument("-y2", "--y2label", help="ylabel for second axis")
ap.add_argument("-y2l", "--y2lims",nargs=2, type=float, help="y axis limits for second axis")
ap.add_argument("--y2log", action='store_true', help="Y2 axis in log scale")
ap.add_argument("-cmap2", "--colormap2", choices = qualitative_colormaps, default='tab10', help="Matplotlib colormap to use for second axis")
# ap.add_argument("--color-cycle2-length", type=int, help="Number of colors to cycle through for each line")
 
args = vars(ap.parse_args())

n_total_files = len(args['files']) + len(args['twinx'])

# NOTE: Using generators/iterators instead of lists allows us to use labels,
# linestyles, markers and linewidths as a pool for both main and twin axes.
# This way only some flags need to be duplicated.

if not args['labels']:
    args['labels'] = iter(args['files'] + args['twinx'])
else: 
    args['labels'] = iter(args['labels'])

if not args['linestyles']:
    args['linestyles'] = iter( [ 'solid' ] * n_total_files ) 
    # args['linestyles'] = []
elif len(args['linestyles']) < n_total_files:
    args['linestyles'] = islice(cycle(args['linestyles']), n_total_files )
else: 
    args['linestyles'] = iter(args['linestyles'])

if not args['markers']:
    args['markers'] = iter([ None ] * n_total_files)
    # args['markers'] = []
elif len(args['markers']) == 1:
    args['markers'] = iter(args['markers'] * n_total_files)
else: 
    args['markers'] = iter(args['markers'])

if not args['linewidths']:
    args['linewidths'] = iter([ 1 ] * n_total_files)
    # args['linewidths'] = []
elif len(args['linewidths']) == 1:
    args['linewidths'] = iter(args['linewidths'] * n_total_files)
else: 
    args['linewidths'] = iter(args['linewidths'])

if not args['zorder']:
    args['zorder'] = iter(range(1,n_total_files+1))
    # args['zorder'] = []
elif len(args['zorder']) == 1:
    args['zorder'] = iter(args['zorder'] * n_total_files)
else:
    args['zorder'] = iter(args['zorder'])


COLORS = plt.cm.get_cmap(args['colormap']).colors[:args['color_cycle_length']]
custom_cycler = cycler('color', COLORS)

COLORS2 = COLORS[len(args['files']):] + COLORS[:len(args['files'])]
custom_cycler2 = cycler('color', COLORS2)

if not args['marker_face_colors']:
    args['marker_face_colors'] = iter(COLORS)
elif len(args['marker_face_colors']) == 1:
    args['marker_face_colors'] = iter(args['marker_face_colors'] * n_total_files)
else:
    args['marker_face_colors'] = iter(args['marker_face_colors'])

with plt.style.context(args['style']):


    # plt.rcParams.update({
    #     "font.family": ["serif"],  
    #     "mathtext.fontset": "dejavuserif",  
    #     "font.serif": ["DejaVu Serif"],  
    #     "font.size":10})          

    ## A way to override the default style
    if args['legend_frameon']:
        plt.rcParams.update({
            "legend.shadow": True,
            "legend.frameon": True })
    else: 
        plt.rcParams.update({
            "legend.shadow": False,
            "legend.frameon": False })

    fig, ax = plt.subplots(figsize=args['fig_size'])
    ax.set_prop_cycle(custom_cycler)

    xtx, xtl = plt.xticks()

    if args['xticks']:
        xtx = args['xticks']
    if args['xtick_labels']:
        xtl = args['xtick_labels']

    if args['xticks'] or args['xtick_labels']: 
        plt.xticks(xtx, xtl)

    setup_main_axis(ax, args)
    lines = plot_things(args['files'], ax, args)

    lines2=[]
    if args['twinx']:
        ax2 = ax.twinx()
        ax2.set_prop_cycle(custom_cycler2)
        setup_twin_axis(ax2, args)
        lines2 = plot_things(args['twinx'], ax2, args)

    if args['hlines']:
        xlim = ax.get_xlim()
        plt.hlines(args['hlines'], xlim[0], xlim[1])

    if args['vlines']:
        ylim = ax.get_ylim()
        plt.vlines(args['vlines'], ylim[0], ylim[1])

    if not args['no_legend']:
        all_lines = lines + lines2 
        all_labels = [l.get_label() for l in all_lines]
        ax.legend(all_lines, all_labels, loc=args['legend'][0], bbox_to_anchor=(float(args['legend'][1]),float(args['legend'][2])), shadow=True, fontsize=args['legend_size'], ncol=args['legend_ncol'])

    if args['output']:
        fig.savefig(args['output'], dpi=300)
    else:
        plt.show()

    if args['write']:
        import csv
        for filename,newname,x,y in zip(args['files'], args['write'], xs, ys):
            with open(newname, 'w') as f:
                writer = csv.writer(f, delimiter=',')
                writer.writerows(zip(x, y))

    if args['split']:
        import csv
        for filename,x,y in zip(args['files'], xs, ys):
            with open(filename + '.x', 'w') as f:
                writer = csv.writer(f, delimiter=',')
                writer.writerows(zip(x))
            with open(filename + '.y', 'w') as f:
                writer = csv.writer(f, delimiter=',')
                writer.writerows(zip(y))

