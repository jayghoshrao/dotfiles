#!/bin/python3

# depends on the mplstyle files from https://github.com/garrettj403/SciencePlots
# USAGE: ./plotChrom.py <file> <file> -o plot.pdf 

# TODO: add option to specify plots as files with only one column each, with x axis defined separately
# TODO: speed up for large files: file-read can be done via np.memmap for binary



import matplotlib as mpl
import matplotlib.pyplot as plt
from cycler import cycler
# import csv
from itertools import cycle, islice
import sys
import argparse
from subprocess import run
from pathlib import Path
import numpy as np

from matplotlib import ticker

from scipy.interpolate import make_interp_spline, BSpline

# SMOOTH: https://stackoverflow.com/questions/5283649/plot-smooth-line-with-pyplot
# COLORS: https://coolors.co/0c5da5-ffcf70-e08300-bc4b51-ac8cba-474747-225851

# COLORS = ['#0C5DA5', '#00B945', '#FF9500', '#FF2C00', '#845B97', '#474747', '#9e9e9e']
# COLORS = ["#0c5da5","#ffcf70","#e08300","#bc4b51","#ac8cba","#474747","#225851"]
# COLORS = plt.cm.viridis(np.linspace(0, 1,7))


qualitative_colormaps = ['Pastel1', 'Pastel2', 'Paired', 'Accent', 'Dark2', 'Set1', 'Set2', 'Set3', 'tab10', 'tab20', 'tab20b', 'tab20c']

def cmap_colors_to_hex(cmap_colors): 
    # USAGE: cmap_colors_to_hex(plt.cm.tab10.colors)
    return list(map(lambda x: mpl.colors.rgb2hex(x), cmap_colors))

def readCSV(data_path):
    time= []
    conc= []
    with open(data_path, newline='') as csvfile:
        # data = list(csv.reader(csvfile))
        for line in csvfile:
            data_line = line.strip().split(',')
            data_line = list(filter(None, data_line))
            if (data_line != []):
                time.append(float(data_line[0]))
                conc.append(float(data_line[1]))
    return time, conc

## MOve to h5plot
def readCadet(infile, unit, solution='outlet'):
    from cadet import Cadet
    from addict import Dict
    cadetpath = "/home/jayghoshter/local/bin/cadet-cli"
    Cadet.cadet_path = cadetpath
    sim = Cadet()
    sim.filename = infile
    sim.load()
    x = sim.root.output.solution.solution_times
    y = sim.root.output.solution['unit_' + "%03d" % unit]['solution_' + solution]
    return x, y

# def normalize(data):
#     return [ x/data[-1] for x in data ]

def normalize(data, refValue=None):
    if refValue == 'self':
        print("No reference value for normalization provided: Using max point of curve.")
        refValue = max(data)
    return [ x/float(refValue) for x in data ]

def readArray(data_path):
    values =[]
    with open(data_path, newline='') as csvfile:
        for line in csvfile:
            values.append(float(line.strip()))
    return values

def readfile(data_path, columns, header=False):
    if ':' in data_path:
        run(['scp', '-rC', data_path, '/tmp/plotting.csv'])
        data_path = '/tmp/plotting.csv'

    x = []
    y = []
    xticksFromFile= None
    xticks = []
    # columns = [0, 1]
    delimiter = ' '
    with open(data_path, newline='') as csvfile:
        if ',' in csvfile.readline():
            delimiter = ','
    with open(data_path, newline='') as infile:
        # data = list(csv.reader(infile))
        if header:
            print(infile.readline())
        for line in infile:
            data_line = line.strip().split(delimiter)
            data_line = list(filter(None, data_line))
            if (data_line != []):
                if len(data_line) == 1:
                    y.append(float(data_line[0]))
                else:
                    x.append(float(data_line[columns[0]]))
                    y.append(float(data_line[columns[1]]))
                # if columns[0] != -1:
                #     x.append(float(data_line[columns[0]]))
                # y.append(float(data_line[columns[1]]))
                if xticksFromFile:
                    xticks.append(float(data_line[columns[xticksFromFile]]))

    return x, y, xticks

def scale_axis(vec:list, scale_factor_or_file):
    if Path(scale_factor_or_file).expanduser().exists():
        scale_factors = readArray(scale_factor_or_file)
        vec = [ v*s for v,s in zip(vec, scale_factors)]
    else: 
        scale_factor = float(scale_factor_or_file)
        vec = [ v * scale_factor for v in vec ]
    return vec

ap = argparse.ArgumentParser()
ap.add_argument("files", nargs='*', help="files to plot")

ap.add_argument("-t", "--title", help="title")
ap.add_argument("-x", "--xlabel", help="xlabel")
ap.add_argument("-y", "--ylabel", help="ylabel")
ap.add_argument("-xl", "--xlims",nargs=2, type=float, help="x axis limits")
ap.add_argument("-yl", "--ylims",nargs=2, type=float, help="y axis limits")
ap.add_argument("-ls", "--linestyles", nargs='*', help="linestyles = solid dashed ...")
ap.add_argument("-lw", "--linewidths", nargs='*', help="linewidth = 0.1 2 ...")
ap.add_argument("-m", "--markers", nargs='*', help="markers = s, o, ...")
ap.add_argument("-n", "--normalize", help="normalize y data to given value or 'self'")
ap.add_argument("-l", "--labels", nargs='*', help="legend labels")
ap.add_argument("-c", "--columns", nargs='*', default = [0,1], type = int, help="columns to plot as x, y. (Partially implemented)")
ap.add_argument("-hg", "--histogram", type=int, help="histogram")
ap.add_argument("-s", "--separator", default=',', help="separator character")

ap.add_argument("-f", "--fill", type=float, help="fill area between provided curve and horizontal baseline at given y value.")
ap.add_argument("--fill-color", help="fill area color")
ap.add_argument("--fill-alpha", default=0.2, type=float, help="Alpha for filled area")
ap.add_argument("--hatch", default='xxx', help="hatch style for filled areas")
ap.add_argument("--hatch-linewidth", type=float, default=0.5, help="hatch linewidth for filled areas")

ap.add_argument("--color-cycle-length", type=int, help="Number of colors to cycle through for each line")
ap.add_argument("-cmap", "--colormap", choices = qualitative_colormaps, default='tab10', help="Matplotlib colormap to use")

ap.add_argument("--header", action='store_true', help="CSV file contains header labels")

ap.add_argument("-nl", "--no-legend", action='store_true', help="don't show legend")
ap.add_argument("--legend", nargs=3, default=['upper center', '0.5', '-0.2'], type=str, help="Legend settings: --legend <location> <bbox_to_anchor>")
ap.add_argument("--legend-frameon", action='store_true', help="Draw frame around legend")
ap.add_argument("--legend-size", default='medium', help="Legend font size:int or {'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'}")
ap.add_argument("--legend-ncol", default=1, type=int, help="Number of columns in legend")

ap.add_argument("--smoothen", nargs='?', type=int, const=250, help="Cubic spline interpolation through provided data")

ap.add_argument("-xs", "--xscale", help="Scale the x axis for all plots by a numerical value or text file with every value")
ap.add_argument("-ys", "--yscale", help="Scale the y axis for all plots by a numerical value or text file with every value")
ap.add_argument("-a", "--aspect", default='auto', help="Set the aspect ratio for the plot")
ap.add_argument("-fs", "--fig-size", nargs=2, default=[4.0, 3.0], type=float, help="Set the figure size for the plot")

ap.add_argument("-hl", "--hlines", nargs='*', type=float, help="Add horizontal lines at these y values")
ap.add_argument("-vl", "--vlines", nargs='*', type=float, help="Add vertical lines at these x values")

ap.add_argument("--xlog", action='store_true', help="X axis in log scale")
ap.add_argument("--ylog", action='store_true', help="Y axis in log scale")

ap.add_argument("--scatter", action='store_true', help="Show a scatter plot")
ap.add_argument("--violin", action='store_true', help="Show a violin plot")

ap.add_argument("-o", "--output", help="output file")
ap.add_argument("-w", "--write", nargs='*', help="Write the CSV file (after applying rescaling if any)")
ap.add_argument("--split", action='store_true', help="Split the data into x and y.")

ap.add_argument("--cadet", nargs=2, help="Read h5 files. --cadet <unit_num> <solution_path>")

ap.add_argument("--style", nargs='*', default=['science'], help="Read h5 files. --cadet <unit_num> <solution_path>")
 

args = vars(ap.parse_args())

if not args['labels']:
    args['labels'] = args['files']

if not args['linestyles']:
    args['linestyles'] = [ 'solid' ] * len(args['files'])
    # args['linestyles'] = []
elif len(args['linestyles']) < len(args['files']):
    args['linestyles'] = list(islice(cycle(args['linestyles']), len(args['files'])))

if not args['markers']:
    args['markers'] = [ None ] * len(args['files'])
    # args['markers'] = []
elif len(args['markers']) == 1:
    args['markers'] = args['markers'] * len(args['files'])

if not args['linewidths']:
    args['linewidths'] = [ 1 ] * len(args['files'])
    # args['linewidths'] = []
elif len(args['linewidths']) == 1:
    args['linewidths'] = args['linewidths'] * len(args['files'])

COLORS = plt.cm.get_cmap(args['colormap']).colors
custom_cycler = cycler('color', COLORS[:args['color_cycle_length']])

with plt.style.context(args['style']):

    # plt.rcParams.update({
    #     "font.family": ["serif"],  
    #     "mathtext.fontset": "dejavuserif",  
    #     "font.serif": ["DejaVu Serif"],  
    #     "font.size":10})          

    ## A way to override the default style
    if args['legend_frameon']:
        plt.rcParams.update({
            "legend.shadow": True,
            "legend.frameon": True })
    else: 
        plt.rcParams.update({
            "legend.shadow": False,
            "legend.frameon": False })

    fig, ax = plt.subplots(figsize=args['fig_size'])
    ax.set_prop_cycle(custom_cycler)

    xs = []
    ys = []

    for filename,label,linestyle,marker,linewidth in zip(args['files'], args['labels'], args['linestyles'], args['markers'], args['linewidths']):
        if args['cadet']:
            x, y = readCadet(filename, int(args['cadet'][0]), args['cadet'][1])
            # print(x,y)
        else:
            x, y, xticks = readfile(filename, args['columns'], args['header'])
        if args['normalize']:
            y = normalize(y, args['normalize'])

        if args['xscale']:
            if x == []:
                x = [1] * len(y)
            x = scale_axis(x, args['xscale'])
        if args['yscale']:
            y = scale_axis(y, args['yscale'])

        if args['smoothen']: 
            xnew = np.linspace(min(x), max(x), args['smoothen']) 
            spl = make_interp_spline(x, y, k=3)  # type: BSpline
            ynew = spl(xnew)
            x = xnew
            y = ynew

        xs.append(x)
        ys.append(y)

        if len(x) > 0: 
            if args['scatter']:
                line = ax.scatter(x, y, label=label.replace('_', '-'), marker=marker)
            else:
                line = ax.plot(x, y, label=label.replace('_', '-'), marker=marker, linestyle=linestyle, linewidth=linewidth)
        else:
            if args['histogram']:
                line = ax.hist(y, bins=args['histogram'])
            elif args['violin']:
                pass
            else:
                line = ax.plot(y, label=label.replace('_', '-'), marker=marker, linestyle=linestyle, linewidth=linewidth)
        if isinstance(args['fill'], float):
            ax.fill_between(x, y, args['fill'], interpolate=True, hatch=args['hatch'], alpha=args['fill_alpha'])
            plt.rcParams['hatch.linewidth'] = args['hatch_linewidth']

    if args['violin']: 
        ax.violinplot(ys)
        positions = np.arange(len(args['labels'])) + 1
        plt.xticks(positions, args['labels'])

        # positions = np.arange(len(args['labels'])) + 1
        # labels = args['labels']
        # ax.xaxis.set_major_locator(ticker.FixedLocator(positions))
        # ax.xaxis.set_major_formatter(ticker.FixedFormatter(labels))

    if not args['no_legend']:
        legend = ax.legend(loc=args['legend'][0], bbox_to_anchor=(float(args['legend'][1]),float(args['legend'][2])), shadow=True, fontsize=args['legend_size'], ncol=args['legend_ncol'])

    ax.set(title=args['title'])
    ax.set(xlabel=args['xlabel'])
    ax.set(ylabel=args['ylabel'])

    if args['xlog']:
        ax.set(xscale="log")
    if args['ylog']:
        ax.set(yscale="log")

    ax.set_aspect(args['aspect'])
    ax.autoscale(tight=True)

    if args['xlims']:
        plt.xlim(args['xlims'])
    if args['ylims']:
        plt.ylim(args['ylims'])

    if args['hlines']:
        xlim = ax.get_xlim()
        plt.hlines(args['hlines'], xlim[0], xlim[1])

    if args['vlines']:
        ylim = ax.get_ylim()
        plt.vlines(args['vlines'], ylim[0], ylim[1])

    if args['output']:
        fig.savefig(args['output'], dpi=300)
    else:
        plt.show()

    if args['write']:
        import csv
        for filename,newname,x,y in zip(args['files'], args['write'], xs, ys):
            with open(newname, 'w') as f:
                writer = csv.writer(f, delimiter=',')
                writer.writerows(zip(x, y))

    if args['split']:
        import csv
        for filename,x,y in zip(args['files'], xs, ys):
            with open(filename + '.x', 'w') as f:
                writer = csv.writer(f, delimiter=',')
                writer.writerows(zip(x))
            with open(filename + '.y', 'w') as f:
                writer = csv.writer(f, delimiter=',')
                writer.writerows(zip(y))
