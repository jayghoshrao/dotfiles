#!/bin/bash

## dex: [d]ecrypt [e]ncrypt e[x]change
# RESOURCE: https://unix.stackexchange.com/questions/387993/how-to-run-a-pipe-safely-and-sequentially/388486#388486

# TODO: recursive  in folder
# TODO: encrypt if not, decrypt if not

set -uo pipefail

MODE='EXCHANGE' ### or EDIT (-e)

LOCKFOLDER="$HOME/.local/share/dex"
[ -d "$LOCKFOLDER" ] || mkdir -p "$LOCKFOLDER"

# LOCKFILE="$HOME/.local/share/dex.lock"

POSITIONAL=()
while [[ $# -gt 0 ]]
do
    key="$1"

    case $key in
        -e|--edit)
            MODE='EDIT'
            shift # past value
            ;;
        -p|--print)
            MODE='PRINT'
            shift # past value
            ;;
        -clf|--clean-lockfiles)
            for FILE in $LOCKFOLDER/*; do 
                LOCK_STATUS=$(flock -n -x "$FILE" echo 'unlocked!')
                [[ -n "$LOCK_STATUS" ]] && rm "$FILE"
            done 
            exit
            ;;
        --pager)
            MODE='PAGER'
            shift # past value
            ;;
        *)    # unknown option
            POSITIONAL+=("$1") # save it in an array for later
            shift # past argument
            ;;
    esac
done
set -- "${POSITIONAL[@]}" # restore positional parameters

FILENAME="$1"
FILEPATH=$(realpath "$FILENAME")
FILEPATHENC=${FILEPATH//\//%}
LOCKFILE="$LOCKFOLDER/$FILEPATHENC"

VIPE_SUFFIX="$(basename "$FILENAME")"

typestr=$(file "$FILENAME")

if [[ "$MODE" == "EXCHANGE" ]]; then 
    if [[ "$typestr" =~ "encrypted" ]]; then 
        result=$(gpg -dq "$FILENAME" ) && printf '%s' "$result" > "$FILENAME"
        unset result
    else
        data=$(gpg -o - -e "$FILENAME" > >(base64)) && printf '%s' "$data" | base64 -d > "$FILENAME"
        unset data
    fi
elif [[ "$MODE" == "PAGER" ]]; then 
    if [[ "$typestr" =~ "encrypted" ]]; then 
        gpg -dq "$FILENAME" | less
    else
        less "$FILENAME"
    fi
elif [[ "$MODE" == "PRINT" ]]; then 
    if [[ "$typestr" =~ "encrypted" ]]; then 
        gpg -dq "$FILENAME"
    else
        cat "$FILENAME"
    fi
elif [[ "$MODE" == "EDIT" ]]; then
    if [[ "$typestr" =~ "encrypted" ]]; then 
        # Uses lockfiles to ensure file is not multiply modified
        ( flock -n 9 || exit 1
        data=$(gpg -dq "$FILENAME" | vipe --suffix "$VIPE_SUFFIX") && gpg -e --batch --yes -o "$FILENAME" < <(printf '%s' "$data")
        unset data
        ) 9>"$LOCKFILE"
    elif [ -f "$FILENAME" ]; then
        # If file exists and not encrypted
        "$EDITOR" "$FILENAME"
    else
        # if file doesn't exist
        # Uses lockfiles to ensure file is not multiply modified
        ( flock -n 9 || exit 1
        data=$(vipe --suffix "$VIPE_SUFFIX") && gpg -e --batch --yes -o "$FILENAME" < <(printf '%s' "$data")
        unset data
        ) 9>"$LOCKFILE"
    fi
fi
